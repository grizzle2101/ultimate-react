---Section 5 - Managing State:---

---1 - Introduction:---
State managment is a fundamental concept in react.
So in this section we're going to take a deep dive into how component state is stored & updated.
This is crucial for building complex applications.



---2 - Understanding the state hook:---
So far we've learned we can use the state hook to add state to a component. A few things you probably didnt know..

1 - react updates state ascynchously (not immediately!)


Test Scenario:
If we create a button that updated the isVisible property, and log it directly after updating the value.
We STILL see the old value.

  const [isVisible, setVisability] = useState(false);

  const dummyOnClick = () => {
    setVisability(true);
    console.log("Visability - ", isVisible);
  };


This is done for performance reasons, in the real world we're going to be updating a lot of data.
So react batches them all togther and does less re-renders.


2 - State is stored outside of components

so we know in javascript variables are scoped locally. If we increment the count and the component re-renders,
we lose the update.
This is the whole reason we store items in scope, outside of the component!

function App() {
  const [isVisible, setVisability] = useState(false);
  let count = 0;

  const dummyOnClick = () => {
    setVisability(true);
    count++;
    console.log("Visability - ", isVisible);
  };


3 - use hooks at the top level of your component

The way react stores state means we have to be careful how we order our hooks.

  const [isVisible, setVisability] = useState(false);
  const [isApproved, setApproved] = useState(true);

The result of these stateHooks will be an array [false, true], which then gets reloaded into the react components
when they re-render.
If we mess up this order by putting them in conditional or nested blocks, we'll state to see the wrong state values
being given.



Take Home:
-react updates are async.
-state is stored outside
-hooks should only be in the top level of our components




---3 - Choosing the state structure:---
So when adding state to a component, its important to look at the strucure of the data.

Cases where we have similar data can be simplified
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [isLoading, setLoading] = useState(false);


TO:
const [person, setPerson] = useState({firstName, lastName});
const [isLoading, setLoading] = useState(false);



The important take home from this section is to avoid deeply nested data structures, as we'll soon find out, its very
difficult to update.
  const [person, setPerson] = useState({
    firstName,
    lastName,
    address: {
      street: {},
    },
  });



  Best Practies:
  -avoid redundant state variables
  -group related variables
  -avoid nested structures


  ---4 - PURE:---
A fundamental concept in react is purity, but what is it?

pure function - given the same input, always returns the same result.
const result = myFunc(1);
// result 'b'

if we get different results, at different times, we call this impure.

React is designed around this concept, it expects every component we create to be a PURE function.

props -> component -> JSX
same props -> skip re-rendering

Take Home:
The take home is keep any changes out of the render phase!

Example:
So say we have a message item that increments a count.

let countNumba = 0;

function Message({ children, count }: MessageProps) {
  countNumba++;
  return (
    <>
      <h1>count - {countNumba}</h1>
    </>
  );
}


Then we use the message component several times, we see a different result for each one!
This is the definition of an IMPURE function.
    <div>
      <Message count={2}>Test</Message>
      <Message count={2}>Test</Message>
      <Message count={2}>Test</Message>
    </div>
  

Refactor:
By simply moving the value down, its reset on each re-render.
Therefore our component produces the same result for each usage, voila!

function Message({ children, count }: MessageProps) {
  let countNumba = 0;
  countNumba++;
  return (
    <>
      <h1>count - {countNumba}</h1>
    </>
  );
}


---5 - Understanding STRICT Mode:---

Previously we got 2, 4 & 6. Why was that? Its to do with strict mode in react.


Strict Mode:
ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


So in main.tsx we have 2 wrappers, reactDOM renders inside the browser, and another strict mode which is used to 
check the compoents.
So in development mode we actually render compoents twice, then react takes the last created instance to render.
This explains 2, 4 & 6, 1, 3 & 5 were not even used!


If we add a console log to the component, we can see this more clearly, 2 logs but only 1 comopnent shown!
note - this is only used in development mode, when we build for production strict mode is removed.
But for now in react 18, strict mode is there by default!

