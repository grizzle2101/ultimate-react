---6 - Connecting to the backend:---
So far we've dealt entirely with React, in the real world we're going to need to connect this to a backend to drive
the application.

Backend Frameworks:
-Express.js
-django
-ruby on rails
-spring
-asp.net core

Building out these backend is beyond the scope of this tutorial series, but we will learn how to integrate with them.



--2 - Understanding the Effect Hook:---
Before we can go into connecting backends, we really need to understand the effect hook.
Earlier we mentioned that react comnponents should be PURE, so provided the same input, should always
have the same output.

        Component:
props -> PURE -> JSX


To keep our Components pure, we have to keep any changes out of the render phase.
There are some scenarios where we might not want that to be the case.

-store data in local storage
-call to server to fetch/save data
-manually modify the DOM

So we cant perform these actions inside the component, thats where the EFFECT HOOK comes in.


UseEffect(() => {})
-to execute a piece of code AFTER the comopnent is rendered.


Example Scenario:
So say we want to focus on an input after the page loads.
So add this functionalty, our component becomes UNPURE. We are updating the state, and will experience side effects.

function App() {
  //ref hook
  const ref = useRef<HTMLInputElement>(null);

  //side effect
  if (ref.current) ref.current.focus();

  return (
    <>
      <div>
        <input ref={ref} type="text" className="form-control" />
      </div>
    </>
  );
}



Some notes on useEffect.
Just like other react hooks, we can only use it at the top level.
So need inside the JSX, loops or if statements.
We can also chain useEffects

  useEffect(() => {
    if (ref.current) ref.current.focus();
  });

  useEffect(() => {
    document.title = "My App";
  });


Take Home:
We use useEffect to modify components after they load, and to keep them pure.




---3 - Effect Dependencies:---



So say we have a product list, we want to simulate loading from a the data from a server.

Example One - UseEffect:
  useEffect(() => {
    console.log("fetching products....");
    setProducts(["clothing", "househole"]);
  });

  return <div>Product List:</div>;


  Result:
  So this useEffect is called a few hundred times, why?
  Because we update the state, which triggered a re-render which trigger another reload and so on! an infinite
  loop!
  Remember we should be using effect away from the component state!


 Lets get this running only once now!

UseEffect Dependencies:
So useEffect has a second parameter, variables we want to pass through each iteration.
It uses these to keep track of state, but if return an empty array it will only ever run once.
   useEffect(() => {
    console.log("fetching products....");
    setProducts(["clothing", "househole"]);
  }, []);

Result:
Congrats, no more infinite loops!


Example - Product Category selector:

-add a product Category selector & set state
 const [category, setCategory] = useState("");

 <select
        className="form-select"
        onChange={(event) => {
          console.log("event - ", event);
          setCategory(event.target.value);
        }}
      >
        <option value=""></option>
        <option value="Clothing">Clothing</option>
        <option value="Household">HouseHold</option>
      </select>

-set props on the productList to take in the Category value
function ProductList({ category }: { category: string }) {

-pass Category in app.tsx
<ProductList category={category} />


-take in state to useEffect:
So given the category, we pretend to fetch the latest products
  useEffect(() => {
    console.log("fetching products in...." + category);
    setProducts(["clothing", "househole"]);
  }, []);



So everything else works, but we dont get category?
The useEffect already ran ONCE, remember? We need to update the useEffect Dependencies.

Fix:
We need to specify the values which trigger our change, so when category changes we re-exectute!
  useEffect(() => {
    console.log("fetching products in...." + category);
    setProducts(["clothing", "househole"]);
  }, [category]);




Take Home:

-NOT providing Dependencies will rerun on EVERY change.
  useEffect(() => {
    console.log("fetching products in...." + category);
    setProducts(["clothing", "househole"]);
  });

-EMPTY bracks will only run once []

-specifying a value means we ONLY execute when that item changes.
  useEffect(() => {
    console.log("fetching products in...." + category);
    setProducts(["clothing", "househole"]);
  }, [category]);


-we can obviously pass in more complex nested object dependencies, will cover this more in depth later.



--- 4 - Effect Clean Up:---
So say we're connecting to a chat server, we need to terminate & clean up when we're done,
How do we go about this?


Task 1 - create 2 functions to simulate connecting & disconnecting:
  const connect = () => console.log("connecting...");
  const disconnect = () => console.log("disconnecting...");


Task 2 - Update useEffect:
optionally useEffect allows us to return a function, which is exectuted on completion.
  useEffect(() => {
    connect();

    return () => disconnect();
  }, []);


Note:
this is exectuted twice, again becuase of STRICT mode in react.

So if connect was an observable subscription, we might unsubscribe in the disconnect function.
-unsubscribe
-close modal
-abort fetch for data



--- 5 - Fetching Data:---
So we're going to connect to a dummy backend, json placeholder.
https://jsonplaceholder.typicode.com/

How are we going to get the data? We can use fetch in the browser, or axios is what many developers go to.


Task 1 - install axios:
npm install axios@1.3.4


Task 2 - create users state to hold the data.
-create users state object.
 const [users, setUsers] = useState<User[]>([]);
 
-define an interfact for the data.
  interface User {
    id: number;
    name: string;
  }



Task 3 - use Axios:
-use axios.get() to fetch our data.
-axios returns a promise, use .then to access data via callback function.
-Then set users using the resulting data.

  useEffect(() => {
    axios
      .get<User[]>("https://jsonplaceholder.typicode.com/users")
      .then((res) => {
        setUsers(res.data); //update state w response.
      });
  }, []);

Note:
Remember the importantance of the empty dependency [], this ensures it only runs once, and doesn't bombard the server.

Task 4 - Render the data:
  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}> {user.name}</li>
      ))}
    </ul>
  );
}



--- 6 - understanding HTTP requests:---
Its important to understand what goes on when we do a get request with AXIOS.


sends a get over HTTP
browser -(request)-> server
browser <-(response )- server
going into the network tab we can filter by fetch/XHR

Note:
Again we have 2 requests becuase we are developing with STRICT mode.

What are the components of a request?
request method - GET
request headers - metadata
body - container for the data
response headers

We will cover this more in depth as needed, including different HTTP methods to update & delete records.



--- 7 - Handling Errors:---
So every developer needs to anticipate errors, how do we handle this in react?
Every promist object in JavaScript has a catch block, we pass in a call back function here.


Task 1 - catch Error:
to simulate network error, see the x in the URL.

  axios
      .get<User[]>("https://jsonplaceholder.typicode.com/usersx")
      .then((res) => {
        setUsers(res.data);
      })
      .catch((err) => {
        setError(err.message);
      });


Task 2 - Display Error to end user:
store the error is a state variable.
  const [error, setError] = useState("");


Modify the display. remember our trick to conidtionally render a section error &&.
Meaning if we have an error return part 2.
 <>
      {error && <p className="text-danger">{error}</p>}



--- 8 - Working with Async & Await:---
Then & catch is not a very popular way of coding, lets check out another way.


Step 1 - Basic Setup:
So couple caveats here.
To use await, we need to define the method as async, with react we cannot do this.
The workaround is to create a function inside, which is markes as async.

useEffect(() => {
  // create async function
    const fetchUsers = async () => {
     const res = await axios.get<User[]>(
          "https://jsonplaceholder.typicode.com/users"
        );
        setUsers(res.data);
    };

  // call the function
    fetchUsers();
  }, []);



Step 2 - Adding Error Handling:
So with async & await we need a try catch block.
-try to do the async call
-catch the error & set errors
useEffect(() => {
    const fetchUsers = async () => {
      try {
        const res = await axios.get<User[]>(
          "https://jsonplaceholder.typicode.com/users"
        );
        setUsers(res.data);
      } catch (error) {
        setError((error as AxiosError).message);
      }
    };
    fetchUsers();
  }, []);


  Take Home:
  This approach does work, but is leads to a a fair amount of overhead, creating an async function inside, try & catch
  then invoking it, casting the error to a type we can erro handle. Is there a cleaner way?


Compare the Code:
In the previous tutorial, using then & catch, what is more readable?
For simplicitys sake we're going to stick with then & catch

  axios
      .get<User[]>("https://jsonplaceholder.typicode.com/usersx")
      .then((res) => setUsers(res.data))
      .catch((err) => setError(err.message);
      );


---9 - Cancelling a fetch Request:---
So earlier we mentioned cleaning up the useEffect, what happens if the user navigates away while
we're fetching data?


Note:
By convention, when we do a fetch inside a useEffect, we should also clean it up!



Example:
-abort controller is a browser feature to abort an action.
-pass this into the axios configuration via signal property.
-return the cleanup function at the end.

 useEffect(() => {
    //part of browser
    const controller = new AbortController();

    axios
      .get<User[]>("https://jsonplaceholder.typicode.com/users", {
        signal: controller.signal,
      })
      .then((res) => setUsers(res.data))
      .catch((err) => {
        if (err instanceof CanceledError) return;
        setError(err.message);
      });

    //cleanup function
    return () => {
      controller.abort();
    };
  }, []);

Note:
Error is being set on load, we need to clean this up by checking if it was a cancellation.


Note:
Because the strict mode, our first component is created & killed very quickly, this is like a user clicking
away, which works perfectly for us!
We can see the first users call is cancelled.