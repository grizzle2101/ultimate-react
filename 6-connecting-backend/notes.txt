---6 - Connecting to the backend:---
So far we've dealt entirely with React, in the real world we're going to need to connect this to a backend to drive
the application.

Backend Frameworks:
-Express.js
-django
-ruby on rails
-spring
-asp.net core

Building out these backend is beyond the scope of this tutorial series, but we will learn how to integrate with them.



--2 - Understanding the Effect Hook:---
Before we can go into connecting backends, we really need to understand the effect hook.
Earlier we mentioned that react comnponents should be PURE, so provided the same input, should always
have the same output.

        Component:
props -> PURE -> JSX


To keep our Components pure, we have to keep any changes out of the render phase.
There are some scenarios where we might not want that to be the case.

-store data in local storage
-call to server to fetch/save data
-manually modify the DOM

So we cant perform these actions inside the component, thats where the EFFECT HOOK comes in.


UseEffect(() => {})
-to execute a piece of code AFTER the comopnent is rendered.


Example Scenario:
So say we want to focus on an input after the page loads.
So add this functionalty, our component becomes UNPURE. We are updating the state, and will experience side effects.

function App() {
  //ref hook
  const ref = useRef<HTMLInputElement>(null);

  //side effect
  if (ref.current) ref.current.focus();

  return (
    <>
      <div>
        <input ref={ref} type="text" className="form-control" />
      </div>
    </>
  );
}



Some notes on useEffect.
Just like other react hooks, we can only use it at the top level.
So need inside the JSX, loops or if statements.
We can also chain useEffects

  useEffect(() => {
    if (ref.current) ref.current.focus();
  });

  useEffect(() => {
    document.title = "My App";
  });


Take Home:
We use useEffect to modify components after they load, and to keep them pure.




---3 - Effect Dependencies:---



So say we have a product list, we want to simulate loading from a the data from a server.

Example One - UseEffect:
  useEffect(() => {
    console.log("fetching products....");
    setProducts(["clothing", "househole"]);
  });

  return <div>Product List:</div>;


  Result:
  So this useEffect is called a few hundred times, why?
  Because we update the state, which triggered a re-render which trigger another reload and so on! an infinite
  loop!
  Remember we should be using effect away from the component state!


 Lets get this running only once now!

UseEffect Dependencies:
So useEffect has a second parameter, variables we want to pass through each iteration.
It uses these to keep track of state, but if return an empty array it will only ever run once.
   useEffect(() => {
    console.log("fetching products....");
    setProducts(["clothing", "househole"]);
  }, []);

Result:
Congrats, no more infinite loops!


Example - Product Category selector:

-add a product Category selector & set state
 const [category, setCategory] = useState("");

 <select
        className="form-select"
        onChange={(event) => {
          console.log("event - ", event);
          setCategory(event.target.value);
        }}
      >
        <option value=""></option>
        <option value="Clothing">Clothing</option>
        <option value="Household">HouseHold</option>
      </select>

-set props on the productList to take in the Category value
function ProductList({ category }: { category: string }) {

-pass Category in app.tsx
<ProductList category={category} />


-take in state to useEffect:
So given the category, we pretend to fetch the latest products
  useEffect(() => {
    console.log("fetching products in...." + category);
    setProducts(["clothing", "househole"]);
  }, []);



So everything else works, but we dont get category?
The useEffect already ran ONCE, remember? We need to update the useEffect Dependencies.

Fix:
We need to specify the values which trigger our change, so when category changes we re-exectute!
  useEffect(() => {
    console.log("fetching products in...." + category);
    setProducts(["clothing", "househole"]);
  }, [category]);




Take Home:

-NOT providing Dependencies will rerun on EVERY change.
  useEffect(() => {
    console.log("fetching products in...." + category);
    setProducts(["clothing", "househole"]);
  });

-EMPTY bracks will only run once []

-specifying a value means we ONLY execute when that item changes.
  useEffect(() => {
    console.log("fetching products in...." + category);
    setProducts(["clothing", "househole"]);
  }, [category]);


-we can obviously pass in more complex nested object dependencies, will cover this more in depth later.